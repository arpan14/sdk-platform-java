package com.google.api.generator.gapic.composer.spanner;

import static org.junit.Assert.assertTrue;

import com.google.api.client.util.Lists;
import com.google.api.core.BetaApi;
import com.google.api.generator.engine.ast.AnnotationNode;
import com.google.api.generator.engine.ast.AssignmentExpr;
import com.google.api.generator.engine.ast.ClassDefinition;
import com.google.api.generator.engine.ast.ConcreteReference;
import com.google.api.generator.engine.ast.Expr;
import com.google.api.generator.engine.ast.ExprStatement;
import com.google.api.generator.engine.ast.MethodDefinition;
import com.google.api.generator.engine.ast.ScopeNode;
import com.google.api.generator.engine.ast.Statement;
import com.google.api.generator.engine.ast.ThisObjectValue;
import com.google.api.generator.engine.ast.TypeNode;
import com.google.api.generator.engine.ast.ValueExpr;
import com.google.api.generator.engine.ast.VaporReference;
import com.google.api.generator.engine.ast.Variable;
import com.google.api.generator.engine.ast.VariableExpr;
import com.google.api.generator.gapic.composer.common.ClassComposer;
import com.google.api.generator.gapic.composer.store.TypeStore;
import com.google.api.generator.gapic.model.GapicClass;
import com.google.api.generator.gapic.model.GapicClass.Kind;
import com.google.api.generator.gapic.model.GapicContext;
import com.google.api.generator.gapic.model.Service;
import com.google.api.generator.gapic.protoparser.ServiceYamlParser;
import com.google.api.pathtemplate.PathTemplate;
import com.google.api.pathtemplate.ValidationException;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import io.grpc.spanner.SpannerOptionsConfig;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Generated;


/**
 * Generate an Option class which represents an Option parameter.
 *
 */
public class SpannerOptionsStubClassComposer implements ClassComposer {
  private static final SpannerOptionsStubClassComposer INSTANCE =
      new SpannerOptionsStubClassComposer();
  private static final TypeStore FIXED_TYPESTORE = createStaticTypes();

  private static final VaporReference READ_AND_QUERY_OPTION =
      createVaporReference("com.google.cloud.spanner", "ReadAndQueryOption");
  private static final VaporReference TRANSACTION_OPTION =
      createVaporReference("com.google.cloud.spanner", "TransactionOption");
  private static final VaporReference INTERNAL_OPTION_REF =
      createVaporReference("com.google.cloud.spanner", "InternalOption");
  private static final VaporReference OPTIONS =
      createVaporReference("com.google.cloud.spanner", "Options");

  public static SpannerOptionsStubClassComposer instance() {
    return INSTANCE;
  }

  @Override
  public GapicClass generate(GapicContext context, Service serivce) {

    // Read the configuration for different options
    SpannerOptionsConfig.OptionMapperConfigList optionMapperConfigList = parseSpannerOptionsConfig();

    /**
     * STEPS that we want to execute
     *
     * 1. define a config for option groups, parse the number of options per group
     * 2. from proto parse the fields which are to be interpreted as options
     * 3. for each field, define the language regex for creating a new method, class, private-variable, getter
     * 4. generate inner classes
     * 5. generate outer class
     */

    // outer class
    ClassDefinition outerClassDef =
        ClassDefinition.builder()
            .setPackageString("com.google.cloud.spanner")
            .setAnnotations(createClassAnnotations())
            .setScope(ScopeNode.PROTECTED)
            .setNestedClasses(Arrays.asList(getClassForOptionProtoField()))
            .setName("AutoGeneratedOptions")
            .build();

    return GapicClass.create(Kind.MAIN, outerClassDef);
  }

  /**
   * TODO generalise it to work for all proto fields, assuming its an option field
   *
   * static final class MaxBatchingDelayMsOption extends InternalOption implements TransactionOption {
   *   private final Integer maxBatchingDelayMs;
   *
   *   MaxBatchingDelayMsOption(Integer maxBatchingDelayMs) {
   *     this.maxBatchingDelayMs = maxBatchingDelayMs;
   *   }
   *
   *   @Override
   *   void appendToOptions(Options options) {
   *     options.maxBatchingDelayMs = maxBatchingDelayMs;
   *   }
   * }
   *
   * @return
   */
  private static ClassDefinition getClassForOptionProtoField() {
    // [code] private final Boolean maxBatchingDelayMs;
    VariableExpr memberVariable = VariableExpr.builder()
        .setIsDecl(true)
        .setScope(ScopeNode.PRIVATE)
        .setIsFinal(true)
        .setVariable(Variable.builder().setName("maxBatchingDelayMs")
            .setType(TypeNode.INT).build())
        .build();

    // create the constructor method
    VaporReference maxBatchingClassRef =
        createVaporReference("com.google.cloud.spanner", "MaxBatchingDelayMsOption");
    VariableExpr valueExpr =
        VariableExpr.withVariable(
            Variable.builder().setName("maxBatchingDelayMs").setType(TypeNode.INT_OBJECT).build());
    VariableExpr thisVariableExpr =
        createVarExprFromRefVarExpr(
            Variable.builder().setName("maxBatchingDelayMs").setType(TypeNode.INT_OBJECT).build(),
            valueExpr);
    AssignmentExpr assignmentExpr =
        AssignmentExpr.builder().setVariableExpr(thisVariableExpr).setValueExpr(valueExpr).build();
    MethodDefinition constructor =
        MethodDefinition.constructorBuilder()
            .setArguments(
                Arrays.asList(VariableExpr.builder()
                    .setIsDecl(true)
                    .setVariable(Variable.builder().setName("maxBatchingDelayMs")
                        .setType(TypeNode.INT).build())
                    .build()))
            .setScope(ScopeNode.PUBLIC)
            .setBody(
                Arrays.asList(ExprStatement.withExpr(assignmentExpr)))
            .setReturnType(TypeNode.withReference(maxBatchingClassRef))
            .build();

    // create append method
    MethodDefinition appendToOptions =
        MethodDefinition.builder()
            .setAnnotations(Arrays.asList(AnnotationNode.OVERRIDE))
            .setArguments()
            .setReturnType(TypeNode.VOID)
            .setName("appendToOptions")
            .setScope(ScopeNode.PUBLIC)
            .setBody(Arrays.asList())
            .build();

    ClassDefinition classDefinition =
        ClassDefinition.builder()
            .setImplementsTypes(Arrays.asList(TypeNode.withReference(TRANSACTION_OPTION)))
            .setExtendsType(TypeNode.withReference(INTERNAL_OPTION_REF))
            .setScope(ScopeNode.PROTECTED)
            .setIsStatic(true)
            .setIsFinal(true)
            .setName("MaxBatchingDelayMsOption")
            .setIsNested(true)
            .setStatements(Arrays.asList(ExprStatement.withExpr(memberVariable)))
            .setMethods(Arrays.asList(constructor, appendToOptions))
            .build();
    return classDefinition;
  }

  private static List<AnnotationNode> createClassAnnotations() {
    return Arrays.asList(
        AnnotationNode.builder()
            .setType(FIXED_TYPESTORE.get("Generated"))
            .setDescription("by gapic-generator-java")
            .build());
  }

  private static TypeStore createStaticTypes() {
    List<Class<?>> concreteClazzes =
        Arrays.asList(
            ArrayList.class,
            BetaApi.class,
            Generated.class,
            ImmutableMap.class,
            List.class,
            Map.class,
            Objects.class,
            PathTemplate.class,
            Preconditions.class,
            com.google.api.resourcenames.ResourceName.class,
            ValidationException.class);
    return new TypeStore(concreteClazzes);
  }

  private static VaporReference createVaporReference(String pkgName, String name) {
    return VaporReference.builder().setPakkage(pkgName).setName(name).build();
  }

  private static Variable createVarFromConcreteRef(ConcreteReference ref, String name) {
    return Variable.builder().setName(name).setType(TypeNode.withReference(ref)).build();
  }

  private static VariableExpr createVarExprFromRefVarExpr(Variable var, Expr varRef) {
    return VariableExpr.builder().setVariable(var).setExprReferenceExpr(varRef).build();
  }

  private SpannerOptionsConfig.OptionMapperConfigList parseSpannerOptionsConfig() {
    String yamlFilename = "com/google/api/generator/gapic/composer/spanner/config/spanner_options_mapper.yaml";
    Path path = Paths.get("src/main/java", yamlFilename);
    Optional<SpannerOptionsConfig.OptionMapperConfigList> optionsMapperSettings =
        SpannerOptionsConfigParser.parse(path.toString());
    return optionsMapperSettings.get();
  }
}

