package com.google.api.generator.gapic.composer.spanner;

import com.google.api.core.BetaApi;
import com.google.api.generator.engine.ast.AnnotationNode;
import com.google.api.generator.engine.ast.AssignmentExpr;
import com.google.api.generator.engine.ast.ClassDefinition;
import com.google.api.generator.engine.ast.ConcreteReference;
import com.google.api.generator.engine.ast.Expr;
import com.google.api.generator.engine.ast.ExprStatement;
import com.google.api.generator.engine.ast.MethodDefinition;
import com.google.api.generator.engine.ast.ScopeNode;
import com.google.api.generator.engine.ast.TypeNode;
import com.google.api.generator.engine.ast.VaporReference;
import com.google.api.generator.engine.ast.Variable;
import com.google.api.generator.engine.ast.VariableExpr;
import com.google.api.generator.gapic.composer.common.ClassComposer;
import com.google.api.generator.gapic.composer.store.TypeStore;
import com.google.api.generator.gapic.model.Field;
import com.google.api.generator.gapic.model.GapicClass;
import com.google.api.generator.gapic.model.GapicClass.Kind;
import com.google.api.generator.gapic.model.GapicContext;
import com.google.api.generator.gapic.model.Message;
import com.google.api.generator.gapic.model.Service;
import com.google.api.generator.gapic.utils.JavaStyle;
import com.google.api.pathtemplate.PathTemplate;
import com.google.api.pathtemplate.ValidationException;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Sets;
import io.grpc.spanner.SpannerOptionsConfig;
import io.grpc.spanner.SpannerOptionsConfig.OptionMapperConfig;
import io.grpc.spanner.SpannerOptionsConfig.OptionMapperConfigList;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.Generated;


/**
 * Generate an Option class which represents an Option parameter.
 *
 */
public class SpannerOptionsStubClassComposer implements ClassComposer {
  private static final SpannerOptionsStubClassComposer INSTANCE =
      new SpannerOptionsStubClassComposer();
  private static final TypeStore FIXED_TYPESTORE = createStaticTypes();

  private static final VaporReference READ_AND_QUERY_OPTION =
      createVaporReference("com.google.cloud.spanner", "ReadAndQueryOption");
  private static final VaporReference TRANSACTION_OPTION =
      createVaporReference("com.google.cloud.spanner", "TransactionOption");
  private static final VaporReference INTERNAL_OPTION_REF =
      createVaporReference("com.google.cloud.spanner", "InternalOption");
  private static final VaporReference OPTIONS =
      createVaporReference("com.google.cloud.spanner", "Options");

  public static SpannerOptionsStubClassComposer instance() {
    return INSTANCE;
  }

  @Override
  public GapicClass generate(GapicContext context, Service serivce) {

    // Read the configuration for mapper
    SpannerOptionsConfig.OptionMapperConfigList optionMapperConfigList = parseSpannerOptionsConfig();

    // from the proto, parse the applicable fields which need to be autogenerated
    Map<Field, String> fields = getApplicableProtoFields(context, optionMapperConfigList);
    /**
     * STEPS that we want to execute
     *
     * 1. define a config for option groups, parse the number of options per group
     * 2. from proto parse the fields which are to be interpreted as options
     * 3. for each field, define the language regex for creating a new method, class, private-variable, getter
     * 4. generate inner classes
     * 5. generate outer class
     */
    List<ClassDefinition> optionClasses = new ArrayList<>();
    for(Map.Entry<Field, String> field: fields.entrySet()) {
      optionClasses.add(getClassForOptionProtoField(field));
    }
    // outer class
    ClassDefinition outerClassDef =
        ClassDefinition.builder()
            .setPackageString("com.google.cloud.spanner")
            .setAnnotations(createClassAnnotations())
            .setScope(ScopeNode.PROTECTED)
            .setNestedClasses(optionClasses)
            .setName("AutoGeneratedOptions")
            .build();

    return GapicClass.create(Kind.MAIN, outerClassDef);
  }

  private Map<Field, String> getApplicableProtoFields(GapicContext context, OptionMapperConfigList optionMapperConfigList) {

    Map<String, String> config = optionMapperConfigList.getValuesList().stream()
        .collect(Collectors.toMap(OptionMapperConfig::getFieldName, OptionMapperConfig::getMappingGroup));
    Map<String, Message> messages = context.messages();
    Map<String, Field> allFields = new HashMap<>();
    Set<String> intersectedFields = new HashSet<>();
    for(Map.Entry<String, Message> entry: messages.entrySet()) {
      Message message = entry.getValue();
      Map<String, Field> fields = message.fieldMap();
      allFields.putAll(fields);
      intersectedFields.addAll(Sets.intersection(config.keySet(), fields.keySet()));
    }
    return intersectedFields.stream().collect(
        Collectors.toMap(fieldName-> allFields.getOrDefault(fieldName, null),
            fieldName -> config.getOrDefault(fieldName, null)));
  }

  /**
   * TODO generalise it to work for all proto fields, assuming its an option field
   *
   * static final class MaxBatchingDelayMsOption extends InternalOption implements TransactionOption {
   *   private final Integer maxBatchingDelayMs;
   *
   *   MaxBatchingDelayMsOption(Integer maxBatchingDelayMs) {
   *     this.maxBatchingDelayMs = maxBatchingDelayMs;
   *   }
   *
   *   @Override
   *   void appendToOptions(Options options) {
   *     options.maxBatchingDelayMs = maxBatchingDelayMs;
   *   }
   * }
   *
   * @return
   */
  private static ClassDefinition getClassForOptionProtoField(
      final Map.Entry<Field, String> field) {
    String nameInLoweCamelCase = JavaStyle.toLowerCamelCase(field.getKey().name());
    String nameInUpperCamelCase = JavaStyle.toUpperCamelCase(field.getKey().name());

    // [code] private final Boolean maxBatchingDelayMs;
    VariableExpr memberVariable = VariableExpr.builder()
        .setIsDecl(true)
        .setScope(ScopeNode.PRIVATE)
        .setIsFinal(true)
        .setVariable(Variable.builder().setName(nameInLoweCamelCase)
            .setType(TypeNode.INT).build())
        .build();

    // create the constructor method
    VaporReference maxBatchingClassRef =
        createVaporReference("com.google.cloud.spanner", nameInUpperCamelCase);
    VariableExpr valueExpr =
        VariableExpr.withVariable(
            Variable.builder().setName(nameInLoweCamelCase).setType(TypeNode.INT_OBJECT).build());
    VariableExpr thisVariableExpr =
        createVarExprFromRefVarExpr(
            Variable.builder().setName(nameInLoweCamelCase).setType(TypeNode.INT_OBJECT).build(),
            valueExpr);
    AssignmentExpr assignmentExpr =
        AssignmentExpr.builder().setVariableExpr(thisVariableExpr).setValueExpr(valueExpr).build();
    MethodDefinition constructor =
        MethodDefinition.constructorBuilder()
            .setArguments(
                Arrays.asList(VariableExpr.builder()
                    .setIsDecl(true)
                    .setVariable(Variable.builder().setName(nameInLoweCamelCase)
                        .setType(TypeNode.INT).build())
                    .build()))
            .setScope(ScopeNode.PUBLIC)
            .setBody(
                Arrays.asList(ExprStatement.withExpr(assignmentExpr)))
            .setReturnType(TypeNode.withReference(maxBatchingClassRef))
            .build();

    // create append method
    MethodDefinition appendToOptions =
        MethodDefinition.builder()
            .setAnnotations(Arrays.asList(AnnotationNode.OVERRIDE))
            .setArguments()
            .setReturnType(TypeNode.VOID)
            .setName("appendToOptions")
            .setScope(ScopeNode.PUBLIC)
            .setBody(Arrays.asList())
            .build();

    ClassDefinition classDefinition =
        ClassDefinition.builder()
            .setImplementsTypes(Arrays.asList(getOptionsGroupTypeNode(field.getValue())))
            .setExtendsType(TypeNode.withReference(INTERNAL_OPTION_REF))
            .setScope(ScopeNode.PROTECTED)
            .setIsStatic(true)
            .setIsFinal(true)
            .setName(nameInUpperCamelCase)
            .setIsNested(true)
            .setStatements(Arrays.asList(ExprStatement.withExpr(memberVariable)))
            .setMethods(Arrays.asList(constructor, appendToOptions))
            .build();
    return classDefinition;
  }

  private static TypeNode getOptionsGroupTypeNode(final String value) {
    // TODO add other mapping groups to the below switch case
    switch (value) {
      case "TransactionOption" :
        return TypeNode.withReference(TRANSACTION_OPTION);
      default:
        return TypeNode.withReference(OPTIONS);
    }
  }

  private static List<AnnotationNode> createClassAnnotations() {
    return Arrays.asList(
        AnnotationNode.builder()
            .setType(FIXED_TYPESTORE.get("Generated"))
            .setDescription("by gapic-generator-java")
            .build());
  }

  private static TypeStore createStaticTypes() {
    List<Class<?>> concreteClazzes =
        Arrays.asList(
            ArrayList.class,
            BetaApi.class,
            Generated.class,
            ImmutableMap.class,
            List.class,
            Map.class,
            Objects.class,
            PathTemplate.class,
            Preconditions.class,
            com.google.api.resourcenames.ResourceName.class,
            ValidationException.class);
    return new TypeStore(concreteClazzes);
  }

  private static VaporReference createVaporReference(String pkgName, String name) {
    return VaporReference.builder().setPakkage(pkgName).setName(name).build();
  }

  private static Variable createVarFromConcreteRef(ConcreteReference ref, String name) {
    return Variable.builder().setName(name).setType(TypeNode.withReference(ref)).build();
  }

  private static VariableExpr createVarExprFromRefVarExpr(Variable var, Expr varRef) {
    return VariableExpr.builder().setVariable(var).setExprReferenceExpr(varRef).build();
  }

  private SpannerOptionsConfig.OptionMapperConfigList parseSpannerOptionsConfig() {
    String yamlFilename = "com/google/api/generator/gapic/composer/spanner/config/spanner_options_mapper.yaml";
    Path path = Paths.get("src/main/java", yamlFilename);
    Optional<SpannerOptionsConfig.OptionMapperConfigList> optionsMapperSettings =
        SpannerOptionsConfigParser.parse(path.toString());
    return optionsMapperSettings.get();
  }
}

